<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ktor的CIO Engine源码分析</title>
    <url>/2020/11/10/ktor-cio/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>犹记得去年写了两篇使用 <code>kotlin</code> 开发 <code>springboot</code> 项目的介绍，后来咕了（<del>逃</del>。</p>
<p>对于大型项目来说，目前 <code>springboot</code> 依然是不二首选（毕竟 <code>Spring Cloud</code> 的那一套生态还是很方便的），但是在个人项目中，我更倾向于使用 <a href="https://github.com/ktorio/ktor">Ktor</a> 。</p>
<a id="more"></a>

<h2 id="Let’s-Roll"><a href="#Let’s-Roll" class="headerlink" title="Let’s Roll"></a>Let’s Roll</h2><p>占个坑，等 ktor 这几天 bump 版本后更新。</p>
]]></content>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Ktor上手篇</title>
    <url>/2020/11/18/ktor-in-practice/</url>
    <content><![CDATA[<p>在 <code>github</code> 上看到了一个不错的库—— <a href="https://github.com/laosepi/setu">setu</a>，寻思正好可以用这个库里面的数据搭配 <code>ktor</code> 做一个随机的色图 api，帮助上手并了解 <code>ktor</code>。</p>
<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>首先，我们要从<a href="https://github.com/laosepi/setu/tree/master/db">数据源</a>下载最新的 <code>json</code> 文件，并将里面的数据导入到数据库中。</p>
<p>由于这个库用来保存色图数据的文件并不符合 <code>json</code> 格式的规范，所以不能直接用工具将整个文件直接导入到数据库中。这里我写了个简单的工具用来解析这个文件并且将文件数据导入到目的数据库，可以到<a href="https://github.com/hikari-dev/setu-import-helper">这里</a>查看具体源码。</p>
<h2 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h2><p>使用 <code>idea</code> 的 <code>ktor</code> 插件可以很方便地创建一个 <code>ktor</code> 项目。来看看 <code>ktor</code> 插件自动给我们生成的代码都是甚摸意思。</p>
<p>在 <code>build.gradle</code> 文件里，<code>ktor</code> 插件在不勾选其它功能的情况下自动帮我们导入了以下这些依赖，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;io.ktor:ktor-server-cio:<span class="variable">$ktor_version</span>&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;ch.qos.logback:logback-classic:<span class="variable">$logback_version</span>&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;io.ktor:ktor-server-core:<span class="variable">$ktor_version</span>&quot;</span>)</span><br><span class="line">testImplementation(<span class="string">&quot;io.ktor:ktor-server-tests:<span class="variable">$ktor_version</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后在 <code>application.kt</code> 文件里，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Unit</span> = io.ktor.server.cio.EngineMain.main(args)</span><br></pre></td></tr></table></figure>

<p>通过 <code>CIO Engine</code> 的 <code>main</code> 方法来启动程序。这样，一个最简单的 <code>ktor application</code> 就搭起来了。</p>
<p>当然，我们可以通过 <code>install</code>  方法给这个应用安装一些常用的 <code>feature</code> ，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加记录日志功能</span></span><br><span class="line">install(CallLogging) &#123;</span><br><span class="line">    level = Level.DEBUG</span><br><span class="line">    filter &#123; call -&gt; call.request.path().startsWith(<span class="string">&quot;/&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加默认header</span></span><br><span class="line">install(DefaultHeaders) &#123;</span><br><span class="line">    header(<span class="string">&quot;X-Engine&quot;</span>, <span class="string">&quot;NM\$L&quot;</span>) <span class="comment">// will send this header with each response</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加默认json解析器</span></span><br><span class="line">install(ContentNegotiation) &#123;</span><br><span class="line">    gson &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加路由，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">routing &#123;</span><br><span class="line">    route(<span class="string">&quot;/api&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">get</span>(<span class="string">&quot;setu&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> setu = fetchSeTuFromDatabase()</span><br><span class="line">            <span class="keyword">if</span> (setu != <span class="literal">null</span>) &#123;</span><br><span class="line">                call.respond(setu)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                call.respondText(<span class="string">&quot;Something went wrong.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> count = <span class="number">10000</span><span class="comment">//replace with your count here</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fetchSeTuFromDatabase</span><span class="params">()</span></span>: SeTu? &#123;</span><br><span class="line">    <span class="keyword">var</span> resultRow: ResultRow? = <span class="literal">null</span></span><br><span class="line">    transaction &#123;</span><br><span class="line">        <span class="keyword">val</span> randomId = Random().nextInt(count) + <span class="number">1</span></span><br><span class="line">        resultRow = SeTuTable.select &#123; SeTuTable.id eq randomId &#125;.firstOrNull()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (resultRow == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SeTu().saveBy(resultRow!!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，一个可以获取随机色图的 <code>api</code> 就完成了！<br>完整代码已放在 <a href="https://github.com/hikari-dev/setu-backend">gtihub</a> 上。</p>
<h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>打开浏览器，访问 <code>localhost:8080/api/setu</code> ,看能否正常输出 <code>json</code> 格式的 <code>response</code> 即可。</p>
]]></content>
  </entry>
  <entry>
    <title>SortAlgosKt(1) - 开个新坑吧，吧卟吧卟之冒泡排序</title>
    <url>/2020/10/30/sort-01/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个天天摸鱼的打工人，最近接触到一些新的知识后，愈发认识到自己的菜了。前几天听别人讲到归并排序算法，一时没想起来是咋个思路来着（<del>此处脸上泛红</del>），跑去查了下才想起来。于是乎想开个新坑，介绍下各排序算法的思路并用 <code>kotlin</code> 一一实现这些排序算法，也借此机会<del>巩固</del>(学习)以前学的各种排序算法。(<del>害，其实除了常用的排序算法，其它的在下都忘得差不多了……</del>) </p>
<p>为啥第一篇选择冒泡排序呢，当然是因为冒泡最出名也最简单啦。</p>
<a id="more"></a>

<h2 id="还是讲正题吧"><a href="#还是讲正题吧" class="headerlink" title="还是讲正题吧"></a>还是讲正题吧</h2><p>本来想抄下<a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">百度百科</a>介绍的冒泡排序的原理，但是感觉blahblah一长串讲得好复杂。我觉得简单来讲，冒泡排序就是<strong>每一趟排序把剩余数组里最大的那个数给找出来并放到相应位置</strong>。这个排序的过程很像气泡在水里的运动规律，一些大小不同的气泡并排躺在水底，最鼓（数值最大）的那个气泡肯定最先浮出水面。</p>
<p>光讲排序思想还是有些抽象，举个例子吧。</p>
<p>对array:[2,4,1,3]进行冒泡排序,如果当前元素比它后面那一个元素小，就执行交换。</p>
<p>第一趟排序:</p>
<p>①index=0，array[0]&lt;array[1]，不执行任何操作，index++</p>
<p>②index=1，array[1]&gt;array[2]，执行swap(1,2)，数组变成[2,1,4,3]，index++</p>
<p>③index=2，array[2]&gt;array[3]，执行swap(2,3)，数组变成[2,1,3,4]，此时index+1==lastIndex，排序结束</p>
<p>第二趟排序：</p>
<p>①index=0，array[0]&gt;array[1]，执行swap(0,1)，数组变成[1,2,3,4]，index++</p>
<p>②index=1，array[1]&lt;array[2]，不执行任何操作，index++，此时index+1==上一趟排出的最大值的index，排序结束</p>
<p>第三趟排序：</p>
<p>①index=0，array[0]&lt;array[1]，不执行任何操作，index++，此时index+1==上一趟排出的最大值的index，排序结束</p>
<p>一共要执行 n-1 趟排序( n 为数组长度)。都执行完毕后，当前数组即为有序的数组(虽然在本例中，第二趟排序结束后就已经是有序数组了，但算法还是要执行完第三趟)。</p>
<p>还不明白的童鞋(假装除了自己还会有别人看<del>其实并没有</del>)，可以试试看一下<a href="https://visualgo.net/zh/sorting">visualgo</a>上面的图，应该也可以帮助理解。 </p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bubbleSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt; <span class="number">2</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//i表示第几趟排序</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until nums.lastIndex - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//j表示这趟排序遍历的索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until nums.lastIndex - i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, j, j + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 之后其它的排序算法还会多次用到这个函数，所以直接抽出来变成一个单独的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">swap</span><span class="params">(nums: <span class="type">IntArray</span>, i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = nums[i]</span><br><span class="line">    nums[i] = nums[j]</span><br><span class="line">    nums[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的实现使用了两层循环，所以时间复杂度为O(n^2)。</p>
<p>冒泡排序并未使用额外变量，所以空间复杂度为O(1)。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个系列应该不会咕咕咕(<del>大概</del>)，下一篇不出意外的话应该是选择排序。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SortAlgosKt(2) - 选择排序</title>
    <url>/2020/11/01/sort-02/</url>
    <content><![CDATA[<p>又是一个颓废的周末，忙着看比赛没怎么学习，罪过罪过。一觉醒来，才知道双11今天凌晨就提前开始了，大家都像打仗一样的奔向战场，而我还在沉浸在香甜的睡梦中（<del>血亏</del>）。不过想想，不买立省100%，也就没那么亏了嘿嘿。不闲扯了，还是来讲讲选择排序吧。</p>
<a id="more"></a>

<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p><a href="https://www.runoob.com/w3cnote/selection-sort.html">runoob</a> 上对选择排序的步骤是这么概括的：</p>
<blockquote>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<p>重复第二步，直到所有元素均排序完毕。</p>
</blockquote>
<p>总结起来就是，<strong>每一趟遍历，找出最小的数放在相应的位置</strong></p>
<p>和冒泡排序不同的是，选择排序每趟下来只会在遍历完所有元素后才会进行一次交换，而冒泡排序则是每趟遍历都有可能会进行多次交换，这也是选择排序略优于冒泡排序的地方（这里针对的是未优化前的冒泡排序，优化后的冒泡排序会检测如果某趟遍历没有发生元素交换，就提前结束排序，所以在某些情况下会优于选择排序）。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">selectionSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt; <span class="number">2</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//i表示第几趟排序</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until nums.lastIndex) &#123;</span><br><span class="line">        <span class="keyword">var</span> minIndex = i<span class="comment">//minIndex表示每趟排序最小值的索引</span></span><br><span class="line">        <span class="comment">//j表示这趟排序遍历的索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span>..nums.lastIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, minIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SortAlgosKt(3) - 插入排序</title>
    <url>/2020/11/03/sort-03/</url>
    <content><![CDATA[<p>这期来讲讲插入排序。</p>
<a id="more"></a>

<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>插入排序的基本思想，就是<strong>对所有元素进行遍历，每一次把当前遍历的元素插入到前面已经排序好的有序队列的相应位置上</strong>。这个过程就很像打扑克时候的理牌，每抽一张牌就把那张牌给放到手牌里的对应位置，<del>如果你喜欢打牌应该很好理解</del>（其实在下并不怎么打牌，只是《算法导论》里举得的这个例子给俺留下了很深刻的印象）。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>实现上使用双循环，外层对所有元素进行遍历（不包括第一个元素，因为第一个元素已经有序）,内层从当前元素往前遍历前面的有序队列，通过每次和前面的一个元素比较交换，查找合适的插入位置。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertionSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt; <span class="number">2</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//i表示第几趟排序</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..nums.lastIndex) &#123;</span><br><span class="line">        <span class="comment">//j表示当前元素每次和有序队列的元素进行比较后的索引</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, j, j - <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SortAlgosKt(4) - 归并排序</title>
    <url>/2020/11/05/sort-04/</url>
    <content><![CDATA[<p>进入正题前，分享下最近看剧学到的一句不错的格言：</p>
<blockquote>
<p>The unhappiest man is one trapped in past memory or future hope,incapable of living in the present.</p>
</blockquote>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>归并排序是分治法的一个经典应用：将原问题分解成规模较小的子问题，递归求解这些子问题，然后合并这些子问题来建立原问题的解。</p>
<p>直接上图吧。</p>
<p><img src="1.png"></p>
<p>在对上面这个数组的排序过程中，先将数组拆到长度最小的有序数组(即只包含一个元素)，然后层层归并，每层待合并的有序序列的长度不断增加，直到最后把长度为原数组一半的两个有序序列合并成最终的结果。</p>
<p>还有个关键问题是如何将两个有序序列合并成一个大的有序序列呢？可以使用双指针法，分别指向两个有序序列的开头。下面的 merge 方法直接给出了实现。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt; <span class="number">2</span>) <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">val</span> mid = nums.size / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> leftArr = nums.copyOfRange(<span class="number">0</span>, mid)</span><br><span class="line">    <span class="keyword">val</span> rightArr = nums.copyOfRange(mid, nums.lastIndex + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(leftArr), mergeSort(rightArr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> ans = IntArray(nums1.size + nums2.size)</span><br><span class="line">    <span class="comment">//《算法导论》里使用的是哨兵法，给每个数组的最后加上大小为正无穷的哨兵元素，可以省去每次检查是否有数组遍历到头了。</span></span><br><span class="line">    <span class="comment">// 此处使用的双指针法，也具有此效果</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= nums1.lastIndex &amp;&amp; j &lt;= nums2.lastIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt;= nums2[j]) &#123;</span><br><span class="line">            ans[i + j] = nums1[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[i + j] = nums2[j]</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= nums1.lastIndex) &#123;</span><br><span class="line">        ans[i + j] = nums1[i]</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= nums2.lastIndex) &#123;</span><br><span class="line">        ans[i + j] = nums2[j]</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SortAlgosKt(5) - 快速排序</title>
    <url>/2020/11/06/sort-05/</url>
    <content><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序和归并排序一样，也是应用了分治的思想。</p>
<a id="more"></a>

<p>算法分为三步：</p>
<ol>
<li>在待排序数组中，选择一个元素作为”基准”（<code>pivot</code>），一般是数组第一个元素。</li>
<li>遍历数组，所有小于 <code>pivot</code> 的元素都移到 <code>pivot</code> 左边；所有大于 <code>pivot</code> 的元素移到 <code>pivot</code> 的右边。</li>
<li>对 <code>pivot</code> 左右两边的数组重复步骤1和步骤2，直到只剩下一个元素为止。</li>
</ol>
<p>关键在于第二步这个分区（<code>partition</code>）的过程如何实现。可以对当前数组进行遍历，并用一个变量标记分割点的位置，分割点表示左边的数都比 <code>pivot</code> 小，右边的都比 <code>pivot</code> 大，遇到比 <code>pivot</code> 小的数就把标记位置右移一位，然后交换标记位置的元素和当前遍历到的元素。遍历结束后，再把 <code>pivot</code> 元素和标记位置的元素进行交换，这次 <code>partition</code> 就算结束了。</p>
<p><code>partition</code> 的过程可以参考下面这个《算法导论》里的图进行理解，只不过这个图是把数组的最后一个数作为 <code>pivot</code> 元素，原理是一样的。我更喜欢直接用第一个元素作为 <code>pivot</code> ，后面实现代码里的 <code>partition</code> 方法也是按照第一个元素来实现的。</p>
<p><img src="1.png"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt; <span class="number">2</span>) <span class="keyword">return</span></span><br><span class="line">    quickSortImpl(nums, <span class="number">0</span>, nums.lastIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSortImpl</span><span class="params">(nums: <span class="type">IntArray</span>, l: <span class="type">Int</span>, r: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">val</span> partition = partition(nums, l, r)</span><br><span class="line">        quickSortImpl(nums, l, partition)</span><br><span class="line">        quickSortImpl(nums, partition + <span class="number">1</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partition</span><span class="params">(nums: <span class="type">IntArray</span>, l: <span class="type">Int</span>, r: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pivot = nums[l]</span><br><span class="line">    <span class="keyword">var</span> i = l</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> l..r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; nums[j]) &#123;</span><br><span class="line">            i++</span><br><span class="line">            swap(nums, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, l, i)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓展-随机快速排序"><a href="#拓展-随机快速排序" class="headerlink" title="拓展 - 随机快速排序"></a>拓展 - 随机快速排序</h2><p>有这么一种情况，待排序数组如果已经有序，那么上面的快速排序方法就会显得效率很低。因为每次把第一个元素作为 <code>pivot</code> 进行 <code>partition</code> 后，总有一个序列是不含任何元素的，此时时间复杂度到达了O(n^2)。这种情况下我们可以使用随机快速排序，也就是每次进行 <code>partition</code> 操作的时候，随机选一个元素作为 <code>pivot</code> ，这样可以实现无论输入数组是否有序，排序时的分区总是相对均衡的。</p>
<p>新增加一个 <code>randPartition</code> 方法用来实现随机快排,</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">randPartition</span><span class="params">(nums: <span class="type">IntArray</span>, l: <span class="type">Int</span>, r: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> randIndex = Random.nextInt(l, r + <span class="number">1</span>)</span><br><span class="line">    swap(nums, randIndex, l)</span><br><span class="line">    <span class="keyword">return</span> partition(nums, l, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改原来调用 <code>partition</code> 方法为调用 <code>randPartition</code> 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSortImpl</span><span class="params">(nums: <span class="type">IntArray</span>, l: <span class="type">Int</span>, r: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">val</span> partition = randPartition(nums, l, r)</span><br><span class="line">        quickSortImpl(nums, l, partition)</span><br><span class="line">        quickSortImpl(nums, partition + <span class="number">1</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SortAlgosKt(6) - 计数排序</title>
    <url>/2020/11/16/sort-06/</url>
    <content><![CDATA[<p>鸽了几天，但是 Better late than never ,俺又回来了，妹想到吧。<br>追 SPN 追到了最新的一集，很喜欢 Cas 说的一句话：</p>
<blockquote>
<p>Happiness isn’t in the having.It’s in just being.It’s in just saying it.</p>
</blockquote>
<a id="more"></a>

<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>前面几篇讲的所有排序算法都是比较算法（在排序的最终结果中，各元素的次序依赖于它们之间的比较）。而计数排序是非比较排序，它的核心思想就是<strong>统计序列中每一种元素出现的次数，由此计算出对于每一个元素，有多少个元素比当前元素小，即可得到当前元素应该排序后应该放置的位置</strong>。具体的实现流程可以看下面的代码注释。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countingSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt; <span class="number">2</span>) <span class="keyword">return</span> nums</span><br><span class="line">    <span class="comment">//获得数组最大值</span></span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        max = Math.max(num, max)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分别统计(0..max)在数组中出现的次数</span></span><br><span class="line">    <span class="keyword">val</span> arr = IntArray(max + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        arr[num] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过累加，计算对于每一个元素，数组中有多少个元素是小于或者等于该元素的</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..arr.lastIndex) &#123;</span><br><span class="line">        arr[i] += arr[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> ans = IntArray(nums.size)</span><br><span class="line">    <span class="comment">//倒序遍历数组，根据上面得到的arr，把每个元素放到相应的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> nums.lastIndex downTo <span class="number">0</span>) &#123;</span><br><span class="line">        ans[arr[nums[i]] - <span class="number">1</span>] = nums[i]</span><br><span class="line">        arr[nums[i]] -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Kotlin的Spring Boot项目搭建指北(一)</title>
    <url>/2019/08/02/springboot-kt-101/</url>
    <content><![CDATA[<h2 id="为什么写这篇文章"><a href="#为什么写这篇文章" class="headerlink" title="为什么写这篇文章"></a>为什么写这篇文章</h2><p><code>Spirng Boot</code> 应该算是当下最流行的 j2ee 开发框架了，但目前大多数都是 <code>java</code> 版本的。上手 <code>kotlin</code> 时间虽然不久，但我确实明显感觉到 <code>kotlin</code> 这门语言带来的方便性，毕竟 jetbrains 那群人开发 <code>kotlin</code> 的时候是更多的是从开发者的角度出发，而 <code>java</code> 感觉有更多的学术研究方面的考虑和历史遗留的问题，所以用起来有时候并不是那么顺手。且不论 <code>kotlin</code> 是不是 “a better java”，单独作为一门编程语言来说，花个一天时间学习一下体验下还是不错的，况且还有 “100% interoperable with java” 呢，不会影响以前的代码hahaha~（等等，这篇文章好像不是来推销 <code>kotlin</code> 的啊）</p>
<a id="more"></a>

<p>言归正传，这篇文章将指引你如何用 <code>kotlin</code> 搭建一个基础的 <code>SpringBoot</code> 项目，适合想学习 <code>kotlin</code> 或者想感受一下用 <code>kotlin</code> 写 server 端代码是什么样的体验的朋友们观看。</p>
<h2 id="下面正式开始"><a href="#下面正式开始" class="headerlink" title="下面正式开始"></a>下面正式开始</h2><h3 id="一、开发环境"><a href="#一、开发环境" class="headerlink" title="一、开发环境"></a>一、开发环境</h3><ul>
<li>idea</li>
<li>jdk</li>
</ul>
<p>首先，开始安装 idea%$^*() ￥%……&amp;#￥%blablabla……</p>
<p>开个玩笑嘿嘿， idea 都不会装没必要看这篇文章了啊魂淡！</p>
<h3 id="二、使用-Spring-Initializer-创建项目"><a href="#二、使用-Spring-Initializer-创建项目" class="headerlink" title="二、使用 Spring Initializer 创建项目"></a>二、使用 Spring Initializer 创建项目</h3><p>把环境都装好后选择 <code>new project</code> 后进入如下界面，选择 <code>Spring Initializer</code> 后点击 <code>Next</code></p>
<p><img src="1.png"></p>
<p>这里 <code>Group</code> 和 <code>Artifact</code> 可以改成自己想要的名字，<code>Language</code> 选择 <code>Kotlin</code>，如果想把应用打成 war 包的话 <code>Packaging</code> 要选择 <code>War</code>，继续点击 Next （什么，你还不知道 war 和 jar 是干嘛的？去百度！！！）</p>
<p><img src="2.png"></p>
<p>把 Web 里面的 <code>Spring Web Starter</code> 勾上后点击 Next</p>
<p><img src="3.png"></p>
<p>这里设置项目名和项目生成路径后点击 Finish，这样，Idea 就会自动为我们开始创建项目啦。（如果首次安装的话可能要经历 Idea 为我们自动下载所有 dependency 的漫长阶段~）</p>
<p><img src="4.png"></p>
<p>在主界面如果看见这个提示可以选择 <code>Enable Auto-Import</code>，这样每次在 <code>pom.xml</code> 里添加依赖的话 idea 会自动去下载相应的 dependency。当然不嫌麻烦的话也可以手动让 idea 去下载依赖－_－b</p>
<p><img src="5.png"></p>
<h3 id="三、相关配置"><a href="#三、相关配置" class="headerlink" title="三、相关配置"></a>三、相关配置</h3><p>首先打开 <code>pom.xml</code>，最好把 kotlin 的版本改成 idea 当前 kotlin 插件的版本</p>
<p><img src="6.png"></p>
<p>然后点击 idea 右上角的绿色箭头，这样一个基于 kt 的 springboot 项目就跑起来了（好了大家下期再见嘿嘿嘿~）</p>
<h3 id="就这？？？"><a href="#就这？？？" class="headerlink" title="就这？？？"></a>就这？？？</h3><p>开个玩笑，要是这么简单就结束了谁知道是不是真正的跑起来，而且这样跑起来有什么用嘛。</p>
<p>接下来就是创建 <code>controller</code> 用于测试是否真的跑起来并且能用了。</p>
<p><img src="7.png"></p>
<p>编写这个 <code>controller</code> 的代码，创建一个 <code>restful</code> 风格的接口</p>
<p><img src="8.png"></p>
<p>重新点击 run，等项目运行起来后，打开浏览器输入 <a href="http://localhost:8080/hello/zhangsan">http://localhost:8080/hello/zhangsan</a>，就可以在浏览器上看到 “Hello，zhangsan!”，说明我们的 <code>SpringBoot</code> 项目真正跑起来来啦！</p>
<p>以上就是最基础的一个基于 <code>Kotlin</code> 的 <code>SpringBoot</code> 项目，后续可以在这个基础框架上加上各种如连接数据库、集成 <code>SpringCloud</code> 等等功能，可以在 Spring 官网查看相关说明，想要学习的小伙伴可以先去看看，以后我也会慢慢写一些集成各种功能的相关教程（咕咕），嘿嘿，这篇文章也就到此为止啦，我们有缘再见！</p>
]]></content>
      <tags>
        <tag>Tutorial</tag>
        <tag>Springboot</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>(已咕)基于Kotlin的Spring Boot项目搭建指北(二)</title>
    <url>/2019/08/13/springboot-kt-mybatis/</url>
    <content><![CDATA[<h2 id="瞎扯两句"><a href="#瞎扯两句" class="headerlink" title="瞎扯两句"></a>瞎扯两句</h2><p>哈喽哈喽哈喽哈喽大家好~ <del>这里是刺猬</del>(误)，这里其实是 <code>Kotlin+Springboot</code> 系列教程的第二篇——整合 <code>mybatis</code>，只是最近在看《乐队的夏天》，对刺猬这个乐队有点喜欢嘿嘿。</p>
<a id="more"></a>

<h2 id="正文来啦"><a href="#正文来啦" class="headerlink" title="正文来啦"></a>正文来啦</h2><p>首先，和上篇文章所写步骤一样，在 idea 用 <code>File → New → project</code> 创建新的项目，唯一区别的地方在于选择需要的 dependencies 的时候要把下面的 <code>MySQL Driver</code> 和 <code>MyBatis Framwork</code> 勾上。</p>
<p><img src="1.png"></p>
<p>由于要使用 Druid 作为连接池的实现，我们还需要导入相应的依赖。打开 <code>pom.xml</code>，在里面添加如下内容:</p>
<p><img src="2.png"></p>
<p>之后创建此次需要连接的数据库，</p>
<p><img src="3.png"></p>
<p>然后简单创建测试用的 <code>user</code> 表，然后随便往里面插几条数据。</p>
<p><img src="4.png"></p>
<p>接着，打开我们项目的配置文件，这里我用的是 <code>application.yml</code> 作为项目配置文件，参考配置如下：</p>
<blockquote>
<p>由于我用的数据库环境是 <code>mysql-8.0.17</code>，所以 jdbc 的 driver 是带 cj 的。如果你用的是5.x.x的版本，driver-class-name 应是 <code>com.mysql.jdbc.Driver</code>。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#jdbc配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://ip:port/dbName?serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">your</span> <span class="string">username</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#连接池的设置</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="comment">#初始化时建立物理连接的个数</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment">#最小连接池数量</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment">#最大连接池数量 maxIdle已经不再使用</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment">#获取连接时最大等待时间，单位毫秒</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment">#申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span></span><br><span class="line">      <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#既作为检测的间隔时间又作为testWhileIdel执行的依据</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment">#销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接</span></span><br><span class="line">      <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment">#用来检测连接是否有效的sql 必须是一个查询语句</span></span><br><span class="line">      <span class="comment">#mysql中为 select &#x27;x&#x27;</span></span><br><span class="line">      <span class="comment">#oracle中为 select 1 from dual</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">select</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">      <span class="comment">#申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line">      <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment">#归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line">      <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment">#是否缓存preparedStatement,mysql5.5+建议开启</span></span><br><span class="line">      <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#当值大于0时poolPreparedStatements会自动修改为true</span></span><br><span class="line">      <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment">#配置扩展插件</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">      <span class="comment">#通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line">      <span class="attr">connection-properties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span></span><br><span class="line">      <span class="comment">#合并多个DruidDataSource的监控数据</span></span><br><span class="line">      <span class="attr">use-global-data-source-stat:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#设置访问druid监控页的账号和密码,默认没有</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">      <span class="comment">#配置WebStatFilter</span></span><br><span class="line">      <span class="attr">web-stat-filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/*</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;</span></span><br></pre></td></tr></table></figure>

<p>至此，基本的环境就搭建完成啦，接下来就是代码的编写了。</p>
<p>按照下图先把文件创建好</p>
<p><img src="5.png"></p>
<p>然后编写 <code>User</code>,</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> id: <span class="built_in">Long</span>,</span><br><span class="line">                <span class="keyword">var</span> name: String,</span><br><span class="line">                <span class="keyword">var</span> age: <span class="built_in">Int</span>,</span><br><span class="line">                <span class="keyword">var</span> gender: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>接着编写 <code>UserMapper</code>,记得一定要加 <code>Mapper注解</code>，这样 Spring Boot 才能扫描到这个 Mapper。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(<span class="meta-string">&quot;select * from user&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllUsers</span><span class="params">()</span></span>: MutableList&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写测试用的 <code>UserController</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> userMapper: UserMapper</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">&quot;getAllUser&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllUsers</span><span class="params">()</span></span>: MutableList&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getAllUsers()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，访问 <a href="http://localhost:8000/getAllUser">http://localhost:8000/getAllUser</a> ,可以看到已经能成功访问到 mysql 里面的数据了,同时也可以打开 <a href="http://localhost:8000/druid">http://localhost:8000/druid</a> 查看 Druid 的监控页面。</p>
<p><img src="6.png"></p>
<p>这样，一个简单的整合了 <code>mybatis</code> 的 Spring Boot 框架就搭建完毕了。</p>
]]></content>
      <tags>
        <tag>Tutorial</tag>
        <tag>Springboot</tag>
        <tag>Kotlin</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>
